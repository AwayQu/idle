/* The following code was generated by JFlex 1.4_pre3 on 30.09.15 15:08 */

package miniparser;

import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.Location;


/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.4_pre3
 * on 30.09.15 15:08 from the specification file
 * <tt>file:/home/petter/cup/testgrammars/minijava2/flex/Scanner.jflex</tt>
 */
public class Lexer implements java_cup.runtime.Scanner, sym, minijava.Constants {

    /** This character denotes the end of file */
    public static final int YYEOF = -1;

    /** initial size of the lookahead buffer */
    private static final int YY_BUFFERSIZE = 16384;

    /** lexical states */
    public static final int STRING = 1;
    public static final int YYINITIAL = 0;

    /**
     * Translates characters to character classes
     */
    private static final char [] yycmap = {
            0,  0,  0,  0,  0,  0,  0,  0,  0, 14, 12,  0, 14, 11,  0,  0,
            0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
            14, 34, 20,  0,  1, 31, 35,  0, 22, 23, 29, 27, 21, 28,  0, 30,
            3,  2,  2,  2,  2,  2,  2,  2,  2,  2,  0, 13, 32, 26, 33,  0,
            0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
            1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0, 37,  0,  0,  1,
            0,  8,  1,  1, 19,  6,  7,  1, 18, 15,  1,  1,  9,  1, 16,  1,
            1,  1,  5, 10,  4,  1,  1, 17,  1,  1,  1, 24, 36, 25,  0,  0
    };


    /**
     * Translates a state to a row index in the transition table (packed version)
     */
    final private static String yy_rowMap_packed =
            "\0\0\0\46\0\114\0\162\0\230\0\114\0\276\0\344\0\u010a\0\114"+
                    "\0\114\0\u0130\0\u0156\0\114\0\114\0\114\0\114\0\114\0\114\0\u017c"+
                    "\0\114\0\114\0\114\0\114\0\114\0\u01a2\0\u01c8\0\u01ee\0\u0214\0\u023a"+
                    "\0\u0260\0\114\0\u0286\0\u02ac\0\u02d2\0\u02f8\0\162\0\u031e\0\u0344\0\u036a"+
                    "\0\114\0\114\0\114\0\114\0\114\0\114\0\114\0\114\0\114\0\114"+
                    "\0\u0390\0\u03b6\0\162\0\u03dc\0\u0402\0\162\0\162\0\u0428\0\u044e\0\162"+
                    "\0\162";

    /**
     * Translates a state to a row index in the transition table
     */
    final private static int [] yy_rowMap = yy_unpack_rowMap(yy_rowMap_packed);


    /**
     * Unpacks the compressed row translation table.
     *
     * @param packed   the packed row translation table
     * @return         the unpacked row translation table
     */
    private static int [] yy_unpack_rowMap(String packed) {
        int [] map = new int[122];
        int i = 0;  /* index in packed string  */
        int j = 0;  /* index in unpacked array */
        while (i < 122) {
            int high = ((int) packed.charAt(i++)) << 16;
            map[j++] = high | packed.charAt(i++);
        }
        return map;
    }
    /**
     * The packed transition table of the DFA (part 0)
     */
    private static final String yy_packed0 =
            "\1\3\1\4\1\5\1\6\1\4\1\7\1\10\4\4"+
                    "\1\11\1\12\1\13\1\12\1\14\1\4\1\15\2\4"+
                    "\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25"+
                    "\1\26\1\27\1\30\1\31\1\32\1\33\1\34\1\35"+
                    "\1\36\1\3\13\37\2\3\7\37\1\40\20\37\1\41"+
                    "\47\0\12\4\4\0\5\4\24\0\2\5\43\0\5\4"+
                    "\1\42\4\4\4\0\5\4\23\0\10\4\1\43\1\4"+
                    "\4\0\5\4\36\0\1\44\32\0\6\4\1\45\3\4"+
                    "\4\0\1\4\1\46\3\4\23\0\4\4\1\47\5\4"+
                    "\4\0\3\4\1\50\1\4\54\0\1\51\45\0\1\52"+
                    "\45\0\1\53\45\0\1\54\56\0\1\55\46\0\1\56"+
                    "\1\0\13\37\2\0\7\37\1\0\20\37\5\0\1\57"+
                    "\1\60\12\0\1\61\3\0\1\62\22\0\7\4\1\63"+
                    "\2\4\4\0\5\4\23\0\11\4\1\64\4\0\5\4"+
                    "\37\0\1\12\31\0\3\4\1\65\6\4\4\0\5\4"+
                    "\23\0\12\4\4\0\1\66\4\4\23\0\12\4\4\0"+
                    "\1\67\4\4\23\0\12\4\4\0\4\4\1\70\23\0"+
                    "\5\4\1\71\4\4\4\0\5\4\23\0\3\4\1\72"+
                    "\6\4\4\0\5\4\23\0\10\4\1\73\1\4\4\0"+
                    "\5\4\23\0\5\4\1\74\4\4\4\0\5\4\23\0"+
                    "\5\4\1\75\4\4\4\0\5\4\22\0";

    /**
     * The transition table of the DFA
     */
    private static final int yytrans [] = yy_unpack();


    /* error codes */
    private static final int YY_UNKNOWN_ERROR = 0;
    private static final int YY_ILLEGAL_STATE = 1;
    private static final int YY_NO_MATCH = 2;
    private static final int YY_PUSHBACK_2BIG = 3;

    /* error messages for the codes above */
    private static final String YY_ERROR_MSG[] = {
            "Unkown internal scanner error",
            "Internal error: unknown state",
            "Error: could not match input",
            "Error: pushback value was too large"
    };

    /**
     * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
     */
    private static final byte YY_ATTRIBUTE[] = {
            0,  0,  9,  1,  1,  9,  1,  1,  1,  9,  9,  1,  1,  9,  9,  9,
            9,  9,  9,  1,  9,  9,  9,  9,  9,  1,  1,  1,  1,  1,  1,  9,
            1,  1,  1,  0,  1,  1,  1,  1,  9,  9,  9,  9,  9,  9,  9,  9,
            9,  9,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1
    };

    /** the input device */
    private java.io.Reader yy_reader;

    /** the current state of the DFA */
    private int yy_state;

    /** the current lexical state */
    private int yy_lexical_state = YYINITIAL;

    /** this buffer contains the current text to be matched and is
     the source of the yytext() string */
    private char yy_buffer[] = new char[YY_BUFFERSIZE];

    /** the textposition at the last accepting state */
    private int yy_markedPos;

    /** the textposition at the last state to be included in yytext */
    private int yy_pushbackPos;

    /** the current text position in the buffer */
    private int yy_currentPos;

    /** startRead marks the beginning of the yytext() string in the buffer */
    private int yy_startRead;

    /** endRead marks the last character in the buffer, that has been read
     from input */
    private int yy_endRead;

    /** number of newlines encountered up to the start of the matched text */
    private int yyline;

    /** the number of characters up to the start of the matched text */
    private int yychar;

    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     */
    private int yycolumn;

    /**
     * yy_atBOL == true <=> the scanner is currently at the beginning of a line
     */
    private boolean yy_atBOL = true;

    /** yy_atEOF == true <=> the scanner is at the EOF */
    private boolean yy_atEOF;

    /** denotes if the user-EOF-code has already been executed */
    private boolean yy_eof_done;

    /* user code: */
    StringBuffer string = new StringBuffer();
    public Lexer(java.io.Reader in, ComplexSymbolFactory sf){
        this(in);
        symbolFactory = sf;
    }
    ComplexSymbolFactory symbolFactory;

    private Symbol symbol(String name, int sym) {
        return symbolFactory.newSymbol(name, sym, new Location(yyline+1,yycolumn+1,yychar), new Location(yyline+1,yycolumn+yylength(),yychar+yylength()));
    }

    private Symbol symbol(String name, int sym, Object val) {
        Location left = new Location(yyline+1,yycolumn+1,yychar);
        Location right= new Location(yyline+1,yycolumn+yylength(), yychar+yylength());
        return symbolFactory.newSymbol(name, sym, left, right,val);
    }
    private Symbol symbol(String name, int sym, Object val,int buflength) {
        Location left = new Location(yyline+1,yycolumn+yylength()-buflength,yychar+yylength()-buflength);
        Location right= new Location(yyline+1,yycolumn+yylength(), yychar+yylength());
        return symbolFactory.newSymbol(name, sym, left, right,val);
    }
    private void error(String message) {
        System.out.println("Error at line "+(yyline+1)+", column "+(yycolumn+1)+" : "+message);
    }


    /**
     * Creates a new scanner
     * There is also a java.io.InputStream version of this constructor.
     *
     * @param   in  the java.io.Reader to read input from.
     */
    public Lexer(java.io.Reader in) {
        this.yy_reader = in;
    }

    /**
     * Creates a new scanner.
     * There is also java.io.Reader version of this constructor.
     *
     * @param   in  the java.io.Inputstream to read input from.
     */
    public Lexer(java.io.InputStream in) {
        this(new java.io.InputStreamReader(in));
    }

    /**
     * Unpacks the split, compressed DFA transition table.
     *
     * @return the unpacked transition table
     */
    private static int [] yy_unpack() {
        int [] trans = new int[1140];
        int offset = 0;
        offset = yy_unpack(yy_packed0, offset, trans);
        return trans;
    }

    /**
     * Unpacks the compressed DFA transition table.
     *
     * @param packed   the packed transition table
     * @return         the index of the last entry
     */
    private static int yy_unpack(String packed, int offset, int [] trans) {
        int i = 0;       /* index in packed string  */
        int j = offset;  /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            value--;
            do trans[j++] = value; while (--count > 0);
        }
        return j;
    }


    /**
     * Refills the input buffer.
     *
     * @return      <code>false</code>, iff there was new input.
     *
     * @exception   IOException  if any I/O-Error occurs
     */
    private boolean yy_refill() throws java.io.IOException {

    /* first: make room (if you can) */
        if (yy_startRead > 0) {
            System.arraycopy(yy_buffer, yy_startRead,
                    yy_buffer, 0,
                    yy_endRead-yy_startRead);

      /* translate stored positions */
            yy_endRead-= yy_startRead;
            yy_currentPos-= yy_startRead;
            yy_markedPos-= yy_startRead;
            yy_pushbackPos-= yy_startRead;
            yy_startRead = 0;
        }

    /* is the buffer big enough? */
        if (yy_currentPos >= yy_buffer.length) {
      /* if not: blow it up */
            char newBuffer[] = new char[yy_currentPos*2];
            System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
            yy_buffer = newBuffer;
        }

    /* finally: fill the buffer with new input */
        int numRead = yy_reader.read(yy_buffer, yy_endRead,
                yy_buffer.length-yy_endRead);

        if (numRead < 0) {
            return true;
        }
        else {
            yy_endRead+= numRead;
            return false;
        }
    }


    /**
     * Closes the input stream.
     */
    public final void yyclose() throws java.io.IOException {
        yy_atEOF = true;            /* indicate end of file */
        yy_endRead = yy_startRead;  /* invalidate buffer    */

        if (yy_reader != null)
            yy_reader.close();
    }


    /**
     * Closes the current stream, and resets the
     * scanner to read from a new input stream.
     *
     * All internal variables are reset, the old input stream
     * <b>cannot</b> be reused (internal buffer is discarded and lost).
     * Lexical state is set to <tt>YY_INITIAL</tt>.
     *
     * @param reader   the new input stream
     */
    public final void yyreset(java.io.Reader reader) throws java.io.IOException {
        yyclose();
        yy_reader = reader;
        yy_atBOL  = true;
        yy_atEOF  = false;
        yy_endRead = yy_startRead = 0;
        yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
        yyline = yychar = yycolumn = 0;
        yy_lexical_state = YYINITIAL;
    }


    /**
     * Returns the current lexical state.
     */
    public final int yystate() {
        return yy_lexical_state;
    }


    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    public final void yybegin(int newState) {
        yy_lexical_state = newState;
    }


    /**
     * Returns the text matched by the current regular expression.
     */
    public final String yytext() {
        return new String( yy_buffer, yy_startRead, yy_markedPos-yy_startRead );
    }


    /**
     * Returns the character at position <tt>pos</tt> from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     *            A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    public final char yycharat(int pos) {
        return yy_buffer[yy_startRead+pos];
    }


    /**
     * Returns the length of the matched text region.
     */
    public final int yylength() {
        return yy_markedPos-yy_startRead;
    }


    /**
     * Reports an error that occured while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that "Can't Possibly Happen".
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param   errorCode  the code of the errormessage to display
     */
    private void yy_ScanError(int errorCode) {
        String message;
        try {
            message = YY_ERROR_MSG[errorCode];
        }
        catch (ArrayIndexOutOfBoundsException e) {
            message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
        }

        throw new Error(message);
    }


    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number  the number of characters to be read again.
     *                This number must not be greater than yylength()!
     */
    private void yypushback(int number)  {
        if ( number > yylength() )
            yy_ScanError(YY_PUSHBACK_2BIG);

        yy_markedPos -= number;
    }


    /**
     * Contains user EOF-code, which will be executed exactly once,
     * when the end of file is reached
     */
    private void yy_do_eof() throws java.io.IOException {
        if (!yy_eof_done) {
            yy_eof_done = true;
            yyclose();
        }
    }


    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return      the next token
     * @exception   IOException  if any I/O-Error occurs
     */
    public java_cup.runtime.Symbol next_token() throws java.io.IOException {
        int yy_input;
        int yy_action;

        // cached fields:
        int yy_currentPos_l;
        int yy_startRead_l;
        int yy_markedPos_l;
        int yy_endRead_l = yy_endRead;
        char [] yy_buffer_l = yy_buffer;
        char [] yycmap_l = yycmap;

        int [] yytrans_l = yytrans;
        int [] yy_rowMap_l = yy_rowMap;
        byte [] yy_attr_l = YY_ATTRIBUTE;

        while (true) {
            yy_markedPos_l = yy_markedPos;

            yychar+= yy_markedPos_l-yy_startRead;

            boolean yy_r = false;
            for (yy_currentPos_l = yy_startRead; yy_currentPos_l < yy_markedPos_l;
                 yy_currentPos_l++) {
                switch (yy_buffer_l[yy_currentPos_l]) {
                    case '\u000B':
                    case '\u000C':
                    case '\u0085':
                    case '\u2028':
                    case '\u2029':
                        yyline++;
                        yycolumn = 0;
                        yy_r = false;
                        break;
                    case '\r':
                        yyline++;
                        yycolumn = 0;
                        yy_r = true;
                        break;
                    case '\n':
                        if (yy_r)
                            yy_r = false;
                        else {
                            yyline++;
                            yycolumn = 0;
                        }
                        break;
                    default:
                        yy_r = false;
                        yycolumn++;
                }
            }

            if (yy_r) {
                // peek one character ahead if it is \n (if we have counted one line too much)
                boolean yy_peek;
                if (yy_markedPos_l < yy_endRead_l)
                    yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
                else if (yy_atEOF)
                    yy_peek = false;
                else {
                    boolean eof = yy_refill();
                    yy_markedPos_l = yy_markedPos;
                    yy_buffer_l = yy_buffer;
                    if (eof)
                        yy_peek = false;
                    else
                        yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
                }
                if (yy_peek) yyline--;
            }
            yy_action = -1;

            yy_startRead_l = yy_currentPos_l = yy_currentPos =
                    yy_startRead = yy_markedPos_l;

            yy_state = yy_lexical_state;


            yy_forAction: {
                while (true) {

                    if (yy_currentPos_l < yy_endRead_l)
                        yy_input = yy_buffer_l[yy_currentPos_l++];
                    else if (yy_atEOF) {
                        yy_input = YYEOF;
                        break yy_forAction;
                    }
                    else {
                        // store back cached positions
                        yy_currentPos  = yy_currentPos_l;
                        yy_markedPos   = yy_markedPos_l;
                        boolean eof = yy_refill();
                        // get translated positions and possibly new buffer
                        yy_currentPos_l  = yy_currentPos;
                        yy_markedPos_l   = yy_markedPos;
                        yy_buffer_l      = yy_buffer;
                        yy_endRead_l     = yy_endRead;
                        if (eof) {
                            yy_input = YYEOF;
                            break yy_forAction;
                        }
                        else {
                            yy_input = yy_buffer_l[yy_currentPos_l++];
                        }
                    }
                    int yy_next = yytrans_l[ yy_rowMap_l[yy_state] + yycmap_l[yy_input] ];
                    if (yy_next == -1) break yy_forAction;
                    yy_state = yy_next;

                    int yy_attributes = yy_attr_l[yy_state];
                    if ( (yy_attributes & 1) == 1 ) {
                        yy_action = yy_state;
                        yy_markedPos_l = yy_currentPos_l;
                        if ( (yy_attributes & 8) == 8 ) break yy_forAction;
                    }

                }
            }

            // store back cached position
            yy_markedPos = yy_markedPos_l;

            switch (yy_action) {

                case 25:
                {  return symbol("le",COMP,  new Integer( LE  ) );  }
                case 62: break;
                case 26:
                {  return symbol("gt",COMP,  new Integer( GT  ) );  }
                case 63: break;
                case 40:
                {  return symbol("eq",COMP,  new Integer( EQ  ) );  }
                case 64: break;
                case 41:
                {  return symbol("leq",COMP,  new Integer( LEQ ) );  }
                case 65: break;
                case 42:
                {  return symbol("gtq",COMP,  new Integer( GTQ ) );  }
                case 66: break;
                case 43:
                {  return symbol("neq",COMP,  new Integer( NEQ ) );  }
                case 67: break;
                case 13:
                {  string.setLength(0); yybegin(STRING);  }
                case 68: break;
                case 56:
                {  return symbol("else",ELSE);  }
                case 69: break;
                case 55:
                {  return symbol("read",READ);  }
                case 70: break;
                case 19:
                {  return symbol("=",ASSIGN);  }
                case 71: break;
                case 27:
                {  return symbol("not",BUNOP);  }
                case 72: break;
                case 30:
                {  string.append( yytext() );  }
                case 73: break;
                case 60:
                {  return symbol("while",WHILE);  }
                case 74: break;
                case 59:
                {  return symbol("write",WRITE);  }
                case 75: break;
                case 14:
                {  return symbol("comma",COMMA);  }
                case 76: break;
                case 2:
                case 28:
                case 29:
                {   /* throw new Error("Illegal character <"+ yytext()+">");*/
                    error("Illegal character <"+ yytext()+">");
                }
                case 77: break;
                case 4:
                case 5:
                {  return symbol("Intconst",INTCONST, new Integer(Integer.parseInt(yytext())));  }
                case 78: break;
                case 52:
                {  return symbol("int",TYPE, new Integer( INTTYPE ) );  }
                case 79: break;
                case 31:
                {  yybegin(YYINITIAL);
                    return symbol("StringConst",STRINGCONST,string.toString(),string.length());  }
                case 80: break;
                case 18:
                {  return symbol("}",END);  }
                case 81: break;
                case 8:
                case 9:
                {  /* ignore */  }
                case 82: break;
                case 36:
                {  return symbol("if",IF);  }
                case 83: break;
                case 17:
                {  return symbol("{",BEGIN);  }
                case 84: break;
                case 16:
                {  return symbol(")",RPAR);  }
                case 85: break;
                case 15:
                {  return symbol("(",LPAR);  }
                case 86: break;
                case 3:
                case 6:
                case 7:
                case 11:
                case 12:
                case 33:
                case 34:
                case 37:
                case 38:
                case 39:
                case 50:
                case 51:
                case 53:
                case 54:
                case 57:
                case 58:
                {  return symbol("Identifier",IDENT, yytext());  }
                case 87: break;
                case 10:
                {  return symbol("semicolon",SEMICOLON);  }
                case 88: break;
                case 32:
                {  string.append('\\');  }
                case 89: break;
                case 46:
                {  string.append('\t');  }
                case 90: break;
                case 47:
                {  string.append('\r');  }
                case 91: break;
                case 48:
                {  string.append('\n');  }
                case 92: break;
                case 49:
                {  string.append('\"');  }
                case 93: break;
                case 24:
                {  return symbol("mod",BINOP, new Integer( MOD ) );  }
                case 94: break;
                case 23:
                {  return symbol("div",BINOP, new Integer( DIV ) );  }
                case 95: break;
                case 22:
                {  return symbol("mult",BINOP, new Integer( MULT ) );  }
                case 96: break;
                case 21:
                {  return symbol("minus",BINOP, new Integer( MINUS ) );  }
                case 97: break;
                case 20:
                {  return symbol("plus",BINOP, new Integer( PLUS ) );  }
                case 98: break;
                case 44:
                {  return symbol("and",BBINOP,new Integer( AND ) );  }
                case 99: break;
                case 45:
                {  return symbol("or",BBINOP,new Integer( OR  ) );  }
                case 100: break;
                default:
                    if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
                        yy_atEOF = true;
                        yy_do_eof();
                        {      return symbolFactory.newSymbol("EOF", EOF, new Location(yyline+1,yycolumn+1,yychar), new Location(yyline+1,yycolumn+1,yychar+1));
                        }
                    }
                    else {
                        yy_ScanError(YY_NO_MATCH);
                    }
            }
        }
    }


}